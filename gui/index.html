<!--
  OpenTDCS Web GUI
  Copyright (C) 2024-2026 Peter Kuhar and OpenTDCS Contributors

  SPDX-License-Identifier: GPL-3.0-or-later

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program. If not, see <https://www.gnu.org/licenses/>.
-->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Open-tDCS-Stack</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@300;400&display=swap');
    
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    :root {
      --bg: #fafaf9;
      --fg: #1c1917;
      --muted: #a8a29e;
      --accent: #3b82f6;
      --danger: #ef4444;
      --success: #22c55e;
      --surface: #fff;
      --border: #e7e5e4;
    }
    
    body {
      font-family: 'IBM Plex Mono', monospace;
      font-weight: 300;
      background: var(--bg);
      color: var(--fg);
      line-height: 1.6;
      min-height: 100vh;
    }
    
    .container {
      max-width: 640px;
      margin: 0 auto;
      padding: 3rem 1.5rem;
    }
    
    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 3rem;
    }
    
    h1 {
      font-weight: 300;
      font-size: 1.25rem;
      letter-spacing: 0.1em;
    }
    
    .status {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.75rem;
      color: var(--muted);
    }
    
    .dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--muted);
    }
    
    .dot.connected { background: var(--accent); }
    .dot.active { background: var(--danger); animation: pulse 1s infinite; }
    
    @keyframes pulse {
      50% { opacity: 0.5; }
    }
    
    section {
      margin-bottom: 3rem;
    }
    
    .card {
      background: var(--surface);
      border: 1px solid var(--border);
      padding: 1.5rem;
      margin-bottom: 1rem;
    }
    
    label {
      display: block;
      font-size: 0.7rem;
      letter-spacing: 0.1em;
      color: var(--muted);
      margin-bottom: 0.5rem;
      text-transform: uppercase;
      white-space: nowrap;
    }
    
    input, textarea, select {
      width: 100%;
      font-family: inherit;
      font-size: 1rem;
      font-weight: 300;
      border: 1px solid var(--border);
      padding: 0.75rem;
      background: var(--bg);
      color: var(--fg);
      outline: none;
    }
    
    input:focus, textarea:focus {
      border-color: var(--fg);
    }
    
    textarea {
      resize: vertical;
      min-height: 80px;
    }
    
    .row {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 1rem;
    }
    
    button {
      font-family: inherit;
      font-size: 0.75rem;
      font-weight: 400;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      padding: 1rem 2rem;
      border: 1px solid var(--fg);
      background: transparent;
      color: var(--fg);
      cursor: pointer;
      transition: all 0.2s;
    }
    
    button:hover {
      background: var(--fg);
      color: var(--bg);
    }
    
    button:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }
    
    button.primary {
      background: var(--fg);
      color: var(--bg);
    }
    
    button.primary:hover {
      background: transparent;
      color: var(--fg);
    }
    
    button.danger {
      border-color: var(--danger);
      color: var(--danger);
    }
    
    button.danger:hover {
      background: var(--danger);
      color: white;
    }
    
    .actions {
      display: flex;
      gap: 1rem;
      margin-top: 1.5rem;
    }
    
    .readings-primary {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 1rem;
      text-align: center;
      margin-bottom: 1rem;
    }
    
    .readings-primary .reading-value {
      font-size: 1.5rem;
      font-weight: 400;
    }
    
    .readings-secondary {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 1rem;
      text-align: center;
      margin-bottom: 1.5rem;
      opacity: 0.6;
    }
    
    .readings-secondary .reading-value {
      font-size: 1rem;
      font-weight: 300;
    }
    
    .reading-unit {
      font-size: 0.7rem;
      color: var(--muted);
    }
    
    .timer {
      font-size: 3rem;
      font-weight: 300;
      text-align: center;
      padding: 2rem;
      letter-spacing: 0.05em;
    }
    
    canvas {
      width: 100%;
      height: 120px;
      display: block;
    }
    
    .graph-label {
      font-size: 0.65rem;
      color: var(--muted);
      margin-bottom: 0.25rem;
    }
    
    .graph-container {
      margin-bottom: 1rem;
    }
    
    .session-list {
      list-style: none;
    }
    
    .session-item {
      padding: 1rem 0;
      border-bottom: 1px solid var(--border);
      font-size: 0.875rem;
      cursor: pointer;
      transition: background 0.2s;
    }

    .session-item:hover {
      background: var(--bg);
    }

    .session-item:last-child {
      border-bottom: none;
    }

    .session-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .session-date {
      color: var(--muted);
      font-size: 0.75rem;
    }

    .session-meta {
      text-align: right;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .delete-btn {
      background: none;
      border: none;
      color: var(--muted);
      font-size: 1.5rem;
      line-height: 1;
      cursor: pointer;
      padding: 0;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: color 0.2s;
    }

    .delete-btn:hover {
      color: var(--fg);
    }

    .session-details {
      display: none;
      margin-top: 1rem;
      padding-top: 1rem;
      border-top: 1px solid var(--border);
    }

    .session-item.expanded .session-details {
      display: block;
    }

    .session-graph {
      margin-bottom: 1rem;
    }

    .session-graph canvas {
      width: 100%;
      height: 80px;
    }

    .session-notes {
      font-size: 0.75rem;
      color: var(--muted);
      font-style: italic;
      margin-top: 0.5rem;
    }
    
    .empty {
      color: var(--muted);
      text-align: center;
      padding: 2rem;
      font-size: 0.875rem;
    }
    
    .hidden { display: none !important; }
    
    #historyChart {
      height: 200px;
    }
    
    .slider-row {
      display: flex;
      align-items: center;
      gap: 1rem;
    }
    
    input[type="range"] {
      flex: 1;
      height: 4px;
      -webkit-appearance: none;
      appearance: none;
      background: var(--border);
      border: none;
      border-radius: 2px;
      cursor: pointer;
    }
    
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: var(--fg);
      cursor: pointer;
    }
    
    input[type="range"]::-moz-range-thumb {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: var(--fg);
      border: none;
      cursor: pointer;
    }
    
    .slider-value {
      font-size: 1.25rem;
      min-width: 5rem;
      text-align: right;
    }

    footer {
      max-width: 640px;
      margin: 0 auto;
      padding: 1rem 1.5rem 3rem;
      color: var(--muted);
      font-size: 0.75rem;
      text-align: center;
    }

    .link { color: inherit; text-decoration: underline; cursor: pointer; }

    .modal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.25);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1rem;
      z-index: 1000;
    }

    .modal-card {
      background: var(--surface);
      border: 1px solid var(--border);
      max-width: 640px;
      width: 100%;
      padding: 1.5rem;
      line-height: 1.5;
    }

    .modal-card h2 {
      font-weight: 300;
      font-size: 1rem;
      margin-bottom: 0.75rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
    }

    .modal-card p { margin-bottom: 0.5rem; }

    .modal-actions { display: flex; gap: 1rem; margin-top: 1rem; justify-content: flex-end; }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>tDCS</h1>
      <div class="status">
        <div class="dot" id="statusDot"></div>
        <span id="statusText">disconnected</span>
      </div>
    </header>

    <section id="connectSection">
      <button id="connectBtn" class="primary">Connect Device</button>
    </section>

    <section id="sessionSection" class="hidden">
      <div class="card">
        <div class="timer" id="timer">00:00</div>
        
        <div class="readings-primary">
          <div>
            <div class="reading-value" id="setCurrentReading">0.0</div>
            <div class="reading-unit">mA set</div>
          </div>
          <div>
            <div class="reading-value" id="currentReading">0.0</div>
            <div class="reading-unit">mA meas</div>
          </div>
          <div>
            <div class="reading-value" id="electrodeVoltageReading">0</div>
            <div class="reading-unit">V elec</div>
          </div>
          <div>
            <div class="reading-value" id="impedanceReading">0</div>
            <div class="reading-unit">kΩ</div>
          </div>
        </div>
        <div class="readings-secondary">
          <div>
            <div class="reading-value" id="lipoReading">0</div>
            <div class="reading-unit">V lipo</div>
          </div>
          <div>
            <div class="reading-value" id="complianceReading">0</div>
            <div class="reading-unit">V comp</div>
          </div>
          <div>
            <div class="reading-value" id="outputReading">0</div>
            <div class="reading-unit">V out</div>
          </div>
        </div>

        <div class="graph-container">
          <div class="graph-label">current</div>
          <canvas id="currentGraph"></canvas>
        </div>
        
        <div class="graph-container">
          <div class="graph-label">impedance</div>
          <canvas id="impedanceGraph"></canvas>
        </div>
      </div>

      <div class="card">
        <label>direct current</label>
        <div class="slider-row">
          <input type="range" id="directCurrent" min="0" max="4" step="0.1" value="0">
          <span class="slider-value" id="directCurrentValue">0.0 mA</span>
        </div>
      </div>

      <div class="card" id="controlCard">
        <div class="row">
          <div>
            <label>current (mA)</label>
            <input type="number" id="targetCurrent" value="2.0" min="0" max="3" step="0.1">
          </div>
          <div>
            <label>duration (min)</label>
            <input type="number" id="duration" value="30" min="1" max="60">
          </div>
          <div>
            <label>ramp (sec)</label>
            <input type="number" id="rampTime" value="60" min="0" max="120">
          </div>
        </div>
        
        <div style="margin-top: 1rem;">
          <label>notes</label>
          <textarea id="notes" placeholder="optional session notes..."></textarea>
        </div>
        
        <div class="actions">
          <button id="startBtn" class="primary">Start Session</button>
          <button id="stopBtn" class="danger hidden">Stop</button>
        </div>
      </div>
    </section>

    <section>
      <div class="card">
        <label>session history</label>
        <canvas id="historyChart"></canvas>
      </div>
      
      <div class="card">
        <ul class="session-list" id="sessionList">
          <li class="empty">no sessions yet</li>
        </ul>
      </div>
    </section>
  </div>

  <footer>
    <span>Not a medical device.</span>
    <span><a id="openDisclaimer" class="link">disclaimer</a></span>
    <span><a id="openSources" class="link">sources</a></span>
  </footer>

  <div id="disclaimerModal" class="modal hidden" role="dialog" aria-modal="true">
    <div class="modal-card">
      <h2>⚠️ Safety Warning</h2>
      <p><strong>This is not a certified medical device.</strong> Incorrect assembly, wiring, or electrode setup can cause dangerous current delivery, leading to <strong>skin burns/lesions</strong>, unintended stimulation effects, equipment failure, or electric shock.</p>
      <p>tDCS/tES should only be performed with <strong>medical-grade, certified equipment</strong> and appropriate screening/supervision—<strong>do not use DIY devices or unvalidated protocols on a person</strong>.</p>
      <p style="margin-top:0.75rem; font-size:0.85em;">Do not use with medical implants or health conditions. Consult a clinician before any human use. Do not use on minors. Stop on discomfort.</p>
      <div class="modal-actions">
        <button id="dismissDisclaimer" class="primary">I understand</button>
        <a href="../DISCLAIMER.md" target="_blank"><button>Full disclaimer</button></a>
      </div>
    </div>
  </div>

  <div id="sourcesModal" class="modal hidden" role="dialog" aria-modal="true">
    <div class="modal-card">
      <h2>Sources</h2>
      <p style="font-size:0.85em; line-height:1.8;">
        <a href="https://www.neurofyziologie.cz/doc/IFCNinfo/Using_tES_devices_as_DIY_FINAL_13Dec15.pdf" target="_blank">IFCN (2015) "tES in DIY applications"</a><br>
        <a href="https://pmc.ncbi.nlm.nih.gov/articles/PMC6050584/" target="_blank">Wurzman et al. (2016) "Open letter on DIY tDCS"</a><br>
        <a href="https://pubmed.ncbi.nlm.nih.gov/23733050/" target="_blank">Fitz & Reiner (2015) "Policy for DIY brain stimulation"</a><br>
        <a href="https://pubmed.ncbi.nlm.nih.gov/27372845/" target="_blank">Bikson et al. (2016) "Safety of tDCS"</a><br>
        <a href="https://www.ifcn.info/UserFiles/file/CLINPH-S-25-01153_Targeted-Safety-Guidelines-update-Oct-2025.pdf" target="_blank">IFCN (2025) "Safety guidelines update"</a><br>
        <a href="https://pubmed.ncbi.nlm.nih.gov/20923600/" target="_blank">Loo et al. (2011) "Avoiding skin burns"</a><br>
        <a href="https://pubmed.ncbi.nlm.nih.gov/25073936/" target="_blank">Rodríguez et al. (2014) "Skin lesions from tDCS"</a><br>
        <a href="https://www.tmslab.org/publications/532.pdf" target="_blank">"Skin Lesions Induced by tDCS" (PDF)</a><br>
        <a href="https://pmc.ncbi.nlm.nih.gov/articles/PMC6166027/" target="_blank">Chao et al. (2018) "Hypomania from tDCS"</a>
      </p>
      <div class="modal-actions">
        <button id="dismissSources" class="primary">Close</button>
      </div>
    </div>
  </div>

  <audio id="endSound" preload="auto">
    <source src="data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdH2Onp+djox9c2lkZGx4iJSdnpuThHlwbG1zfoqUnp2YjoN3cG5xeISOl5uYkYd9dXJxdXyFjpSXlI2FeXNxc3h/iI+TlI+Jf3dzcnR4foaLj5CLibt8d3R1d3x/hYmLi4iFfnl2dnd5fIGFh4iFgn56d3Z3eXyAg4WFg4B8eXd2d3l7foGDg4F/fHl3dnd5e36AgYGAfnx5d3d4eXt9f4CAfn17eXh3eHl7fX5/fn17enh4eHl6fH1+fn18e3l4eHl6e3x9fX18e3p5eHl5ent8fHx8e3p5eXl5enp7fHx8e3t6enl5eXp6e3t7e3t7enp5eXl6ent7e3t7e3p6enl5enp6e3t7e3t6enp6eXl6enp7e3t7e3p6enp5eXp6ent7e3t7enp6enp6enp6e3t7e3p6enp6enp6enp7e3t7enp6enp6" type="audio/wav">
  </audio>

  <script>
    const SERVICE_UUID = 'a1b2c3d4-1234-5678-abcd-ef0123456789'
    const READINGS_UUID = 'a1b2c3d5-1234-5678-abcd-ef0123456789'
    const CONTROL_UUID = 'a1b2c3d6-1234-5678-abcd-ef0123456789'

    let device, server, readingsChar, controlChar
    let sessionActive = false
    let sessionStart = null
    let sessionDuration = 0
    let timerInterval = null
    let graphInterval = null
    
    const currentData = []
    const impedanceData = []
    const maxDataPoints = 120

    const sessions = JSON.parse(localStorage.getItem('tdcs-sessions') || '[]')

    const $ = id => document.getElementById(id)

    function updateStatus(connected, active = false) {
      const dot = $('statusDot')
      const text = $('statusText')
      
      dot.className = 'dot'
      if (active) {
        dot.classList.add('active')
        text.textContent = 'active'
      } else if (connected) {
        dot.classList.add('connected')
        text.textContent = 'connected'
      } else {
        text.textContent = 'disconnected'
      }
    }

    async function connect() {
      try {
        device = await navigator.bluetooth.requestDevice({
          filters: [{ services: [SERVICE_UUID] }]
        })

        device.addEventListener('gattserverdisconnected', onDisconnect)

        server = await device.gatt.connect()
        const service = await server.getPrimaryService(SERVICE_UUID)

        readingsChar = await service.getCharacteristic(READINGS_UUID)
        controlChar = await service.getCharacteristic(CONTROL_UUID)

        await readingsChar.startNotifications()
        readingsChar.addEventListener('characteristicvaluechanged', onReadings)

        await controlChar.startNotifications()
        controlChar.addEventListener('characteristicvaluechanged', onTimerUpdate)

        // Read current session state
        const timerValue = await controlChar.readValue()
        onTimerUpdate({ target: { value: timerValue } })

        $('connectSection').classList.add('hidden')
        $('sessionSection').classList.remove('hidden')
        updateStatus(true)

        startGraphUpdate()
      } catch (e) {
        console.error(e)
      }
    }

    function onDisconnect() {
      $('connectSection').classList.remove('hidden')
      $('sessionSection').classList.add('hidden')
      updateStatus(false)
      stopSession()
    }

    function onReadings(event) {
      const data = new DataView(event.target.value.buffer)
      
      const setCurrent = data.getUint16(0, true) / 1000
      const measuredCurrent = data.getUint16(2, true) / 1000
      const complianceVoltage = data.getUint16(4, true) / 1000
      const outputVoltage = data.getUint16(6, true) / 1000
      const impedance = data.getUint16(8, true) / 1000
      const lipoVoltage = data.byteLength >= 12 ? data.getUint16(10, true) / 1000 : 0
      const electrodeVoltage = complianceVoltage - outputVoltage
      
      $('setCurrentReading').textContent = setCurrent.toFixed(1)
      $('currentReading').textContent = measuredCurrent.toFixed(2)
      $('electrodeVoltageReading').textContent = electrodeVoltage.toFixed(1)
      $('impedanceReading').textContent = impedance.toFixed(1)
      
      $('lipoReading').textContent = lipoVoltage.toFixed(2)
      $('complianceReading').textContent = complianceVoltage.toFixed(1)
      $('outputReading').textContent = outputVoltage.toFixed(1)
      
      
      currentData.push(measuredCurrent)
      impedanceData.push(impedance)
      
      if (currentData.length > maxDataPoints) currentData.shift()
      if (impedanceData.length > maxDataPoints) impedanceData.shift()
    }

    function onTimerUpdate(event) {
      const data = new DataView(event.target.value.buffer)

      const targetCurrent = data.getUint16(0, true)
      const timeRemaining = data.getUint16(2, true)
      const rampUp = data.getUint16(4, true)
      const rampDown = data.getUint16(6, true)

      // Check if there's an active session
      if (targetCurrent > 0 && timeRemaining > 0) {
        if (!sessionActive) {
          // Session is running but UI doesn't know - sync state
          sessionActive = true

          // Calculate original session duration and start time
          // We can't know the exact original duration, so use current timeRemaining
          sessionDuration = timeRemaining
          sessionStart = Date.now()

          // Update input fields with current session parameters
          $('targetCurrent').value = (targetCurrent / 1000).toFixed(1)
          $('rampTime').value = rampUp

          // Update UI
          $('startBtn').classList.add('hidden')
          $('stopBtn').classList.remove('hidden')
          $('controlCard').querySelectorAll('input, textarea').forEach(el => el.disabled = true)
          updateStatus(true, true)

          if (!timerInterval) {
            timerInterval = setInterval(updateTimer, 1000)
          }
        }

        // Update timer display from device
        const mins = Math.floor(timeRemaining / 60)
        const secs = timeRemaining % 60
        $('timer').textContent = `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`
      } else if (sessionActive) {
        // Session ended on device side
        stopSession()
      }
    }

    async function startSession() {
      const targetCurrent = parseFloat($('targetCurrent').value)
      const duration = parseInt($('duration').value) * 60
      const rampTime = parseInt($('rampTime').value)
      
      const buffer = new ArrayBuffer(8)
      const view = new DataView(buffer)
      view.setUint16(0, targetCurrent * 1000, true)
      view.setUint16(2, duration, true)
      view.setUint16(4, rampTime, true)
      view.setUint16(6, rampTime, true)
      
      await controlChar.writeValue(buffer)
      
      sessionActive = true
      sessionStart = Date.now()
      sessionDuration = duration
      
      currentData.length = 0
      impedanceData.length = 0
      
      $('startBtn').classList.add('hidden')
      $('stopBtn').classList.remove('hidden')
      $('controlCard').querySelectorAll('input, textarea').forEach(el => el.disabled = true)
      
      updateStatus(true, true)
      
      timerInterval = setInterval(updateTimer, 1000)
    }

    async function stopSession() {
      if (!sessionActive) return
      
      const buffer = new ArrayBuffer(8)
      new DataView(buffer).setUint16(0, 0, true)
      
      if (controlChar) {
        try {
          await controlChar.writeValue(buffer)
        } catch (e) {}
      }
      
      const elapsed = Math.floor((Date.now() - sessionStart) / 1000)
      
      if (elapsed > 10) {
        const session = {
          id: Date.now(),
          date: new Date().toISOString(),
          duration: elapsed,
          current: parseFloat($('targetCurrent').value),
          notes: $('notes').value,
          currentData: [...currentData],
          impedanceData: [...impedanceData]
        }

        sessions.unshift(session)
        localStorage.setItem('tdcs-sessions', JSON.stringify(sessions))
        renderSessions()
        renderHistoryChart()
      }
      
      sessionActive = false
      clearInterval(timerInterval)
      
      $('timer').textContent = '00:00'
      $('startBtn').classList.remove('hidden')
      $('stopBtn').classList.add('hidden')
      $('controlCard').querySelectorAll('input, textarea').forEach(el => el.disabled = false)
      $('notes').value = ''
      
      updateStatus(!!server?.connected)
      
      $('endSound').play().catch(() => {})
    }

    function updateTimer() {
      // This function now only serves as a backup for timer display
      // The device notifications (onTimerUpdate) are the primary timer source
      // and will signal when the session ends
      const elapsed = Math.floor((Date.now() - sessionStart) / 1000)
      const remaining = Math.max(0, sessionDuration - elapsed)

      // Only update display if we're not receiving device updates
      // (device updates will overwrite this via onTimerUpdate)
      const mins = Math.floor(remaining / 60)
      const secs = remaining % 60
      $('timer').textContent = `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`
    }

    function drawGraph(canvas, data, maxVal, color) {
      const ctx = canvas.getContext('2d')
      const dpr = window.devicePixelRatio || 1
      const rect = canvas.getBoundingClientRect()

      canvas.width = rect.width * dpr
      canvas.height = rect.height * dpr
      ctx.scale(dpr, dpr)

      ctx.clearRect(0, 0, rect.width, rect.height)

      if (data.length < 2) return

      ctx.strokeStyle = color
      ctx.lineWidth = 1.5
      ctx.beginPath()

      const step = rect.width / (maxDataPoints - 1)
      const yScale = rect.height / maxVal

      data.forEach((val, i) => {
        const x = i * step
        const y = rect.height - val * yScale
        if (i === 0) ctx.moveTo(x, y)
        else ctx.lineTo(x, y)
      })

      ctx.stroke()
    }

    function drawSessionGraph(canvas, data, maxVal, color) {
      const ctx = canvas.getContext('2d')
      const dpr = window.devicePixelRatio || 1
      const rect = canvas.getBoundingClientRect()

      canvas.width = rect.width * dpr
      canvas.height = rect.height * dpr
      ctx.scale(dpr, dpr)

      ctx.clearRect(0, 0, rect.width, rect.height)

      if (!data || data.length < 2) return

      const padding = { left: 30, right: 10, top: 15, bottom: 20 }
      const graphWidth = rect.width - padding.left - padding.right
      const graphHeight = rect.height - padding.top - padding.bottom

      // Draw axes
      ctx.strokeStyle = '#e7e5e4'
      ctx.lineWidth = 1
      ctx.beginPath()
      // Y-axis
      ctx.moveTo(padding.left, padding.top)
      ctx.lineTo(padding.left, rect.height - padding.bottom)
      // X-axis
      ctx.lineTo(rect.width - padding.right, rect.height - padding.bottom)
      ctx.stroke()

      // Y-axis labels
      ctx.fillStyle = '#a8a29e'
      ctx.font = '9px IBM Plex Mono'
      ctx.textAlign = 'right'
      ctx.textBaseline = 'middle'
      ctx.fillText(maxVal.toFixed(1), padding.left - 5, padding.top)
      ctx.fillText((maxVal / 2).toFixed(1), padding.left - 5, padding.top + graphHeight / 2)
      ctx.fillText('0', padding.left - 5, rect.height - padding.bottom)

      // X-axis labels (time in minutes)
      const totalSeconds = data.length * 0.5  // 500ms per data point
      const totalMinutes = totalSeconds / 60
      ctx.textAlign = 'center'
      ctx.textBaseline = 'top'
      ctx.fillText('0min', padding.left, rect.height - padding.bottom + 5)

      // Add middle label if duration is long enough
      if (totalMinutes >= 2) {
        const midMinutes = (totalMinutes / 2).toFixed(1)
        ctx.fillText(`${midMinutes}min`, padding.left + graphWidth / 2, rect.height - padding.bottom + 5)
      }

      ctx.fillText(`${totalMinutes.toFixed(1)}min`, rect.width - padding.right, rect.height - padding.bottom + 5)

      // Draw data line
      ctx.strokeStyle = color
      ctx.lineWidth = 1.5
      ctx.beginPath()

      const step = graphWidth / (data.length - 1)
      const yScale = graphHeight / maxVal

      data.forEach((val, i) => {
        const x = padding.left + i * step
        const y = rect.height - padding.bottom - val * yScale
        if (i === 0) ctx.moveTo(x, y)
        else ctx.lineTo(x, y)
      })

      ctx.stroke()
    }

    function startGraphUpdate() {
      graphInterval = setInterval(() => {
        drawGraph($('currentGraph'), currentData, 2.5, '#3b82f6')
        drawGraph($('impedanceGraph'), impedanceData, 20, '#22c55e')
      }, 500)
    }

    function renderSessions() {
      const list = $('sessionList')

      if (sessions.length === 0) {
        list.innerHTML = '<li class="empty">no sessions yet</li>'
        return
      }

      list.innerHTML = sessions.slice(0, 20).map((s, idx) => {
        const date = new Date(s.date)
        const dateStr = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })
        const timeStr = date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' })
        const mins = Math.floor(s.duration / 60)
        const secs = s.duration % 60
        const hasData = s.currentData && s.currentData.length > 0

        return `
          <li class="session-item" data-session-idx="${idx}">
            <div class="session-header">
              <div>
                <div>${mins}:${secs.toString().padStart(2, '0')}</div>
                <div class="session-date">${dateStr} ${timeStr}</div>
              </div>
              <div class="session-meta">
                ${s.current} mA
                <button class="delete-btn" data-session-idx="${idx}" title="Delete session">×</button>
              </div>
            </div>
            ${hasData ? `
              <div class="session-details">
                <div class="session-graph">
                  <div class="graph-label">current</div>
                  <canvas id="sessionCurrent${idx}"></canvas>
                </div>
                <div class="session-graph">
                  <div class="graph-label">impedance</div>
                  <canvas id="sessionImpedance${idx}"></canvas>
                </div>
                ${s.notes ? `<div class="session-notes">${s.notes}</div>` : ''}
              </div>
            ` : ''}
          </li>
        `
      }).join('')

      // Add click handlers
      list.querySelectorAll('.session-item').forEach(item => {
        const idx = parseInt(item.dataset.sessionIdx)
        const session = sessions[idx]

        item.addEventListener('click', () => {
          if (!session.currentData || session.currentData.length === 0) return

          const isExpanded = item.classList.contains('expanded')

          // Close all other expanded items
          list.querySelectorAll('.session-item').forEach(i => i.classList.remove('expanded'))

          if (!isExpanded) {
            item.classList.add('expanded')

            // Draw graphs
            setTimeout(() => {
              const currentCanvas = document.getElementById(`sessionCurrent${idx}`)
              const impedanceCanvas = document.getElementById(`sessionImpedance${idx}`)

              if (currentCanvas && impedanceCanvas) {
                drawSessionGraph(currentCanvas, session.currentData, 2.5, '#3b82f6')
                drawSessionGraph(impedanceCanvas, session.impedanceData, 20, '#22c55e')
              }
            }, 50)
          }
        })
      })

      // Add delete button handlers
      list.querySelectorAll('.delete-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation() // Prevent expanding the session
          const idx = parseInt(btn.dataset.sessionIdx)

          if (confirm('Delete this session?')) {
            sessions.splice(idx, 1)
            localStorage.setItem('tdcs-sessions', JSON.stringify(sessions))
            renderSessions()
            renderHistoryChart()
          }
        })
      })
    }

    function renderHistoryChart() {
      const canvas = $('historyChart')
      const ctx = canvas.getContext('2d')
      const dpr = window.devicePixelRatio || 1
      const rect = canvas.getBoundingClientRect()
      
      canvas.width = rect.width * dpr
      canvas.height = rect.height * dpr
      ctx.scale(dpr, dpr)
      
      ctx.clearRect(0, 0, rect.width, rect.height)
      
      if (sessions.length === 0) return
      
      const last30 = sessions.slice(0, 30).reverse()
      const maxDuration = Math.max(...last30.map(s => s.duration), 1200)
      
      const barWidth = (rect.width - 40) / last30.length - 4
      const padding = 20
      
      ctx.fillStyle = '#a8a29e'
      ctx.font = '10px IBM Plex Mono'
      ctx.textAlign = 'center'
      
      last30.forEach((s, i) => {
        const x = padding + i * (barWidth + 4)
        const h = (s.duration / maxDuration) * (rect.height - 40)
        const y = rect.height - padding - h

        ctx.fillStyle = '#1c1917'
        ctx.fillRect(x, y, barWidth, h)

        // Duration label above bar
        if (h > 20) {
          ctx.fillStyle = '#a8a29e'
          ctx.font = '9px IBM Plex Mono'
          const durationMins = Math.floor(s.duration / 60)
          ctx.fillText(`${durationMins}m`, x + barWidth / 2, y - 4)
        }

        // Date label at bottom
        if (last30.length <= 15 || i % 3 === 0) {
          ctx.fillStyle = '#a8a29e'
          ctx.font = '10px IBM Plex Mono'
          const date = new Date(s.date)
          ctx.fillText(date.getDate(), x + barWidth / 2, rect.height - 4)
        }
      })
    }

    async function setDirectCurrent(value) {
      if (!controlChar) return

      const buffer = new ArrayBuffer(8)
      const view = new DataView(buffer)
      view.setUint16(0, value * 1000, true)
      view.setUint16(2, value > 0 ? 3600 : 0, true) // 1 hour duration
      view.setUint16(4, 0, true) // no ramp
      view.setUint16(6, 0, true)

      try {
        await controlChar.writeValue(buffer)
      } catch (e) {
        console.error(e)
      }
    }

    $('directCurrent').addEventListener('input', (e) => {
      const value = parseFloat(e.target.value)
      $('directCurrentValue').textContent = `${value.toFixed(1)} mA`
      $('setCurrentReading').textContent = value.toFixed(1)
    })
    
    $('directCurrent').addEventListener('change', (e) => {
      const value = parseFloat(e.target.value)
      setDirectCurrent(value)
    })

    $('connectBtn').addEventListener('click', connect)
    $('startBtn').addEventListener('click', startSession)
    $('stopBtn').addEventListener('click', stopSession)

    renderSessions()
    renderHistoryChart()
    
    function showDisclaimer(force = false) {
      if (!force && localStorage.getItem('tdcs-disclaimer-ack') === '1') return
      $('disclaimerModal').classList.remove('hidden')
    }

    $('openDisclaimer').addEventListener('click', () => showDisclaimer(true))
    $('dismissDisclaimer').addEventListener('click', () => {
      localStorage.setItem('tdcs-disclaimer-ack', '1')
      $('disclaimerModal').classList.add('hidden')
    })

    $('openSources').addEventListener('click', () => $('sourcesModal').classList.remove('hidden'))
    $('dismissSources').addEventListener('click', () => $('sourcesModal').classList.add('hidden'))

    document.addEventListener('DOMContentLoaded', () => showDisclaimer(false))
    
    window.addEventListener('resize', () => {
      renderHistoryChart()
      drawGraph($('currentGraph'), currentData, 2.5, '#3b82f6')
      drawGraph($('impedanceGraph'), impedanceData, 20, '#22c55e')

      // Redraw expanded session graphs
      document.querySelectorAll('.session-item.expanded').forEach(item => {
        const idx = parseInt(item.dataset.sessionIdx)
        const session = sessions[idx]
        if (session && session.currentData) {
          const currentCanvas = document.getElementById(`sessionCurrent${idx}`)
          const impedanceCanvas = document.getElementById(`sessionImpedance${idx}`)
          if (currentCanvas && impedanceCanvas) {
            drawSessionGraph(currentCanvas, session.currentData, 2.5, '#3b82f6')
            drawSessionGraph(impedanceCanvas, session.impedanceData, 20, '#22c55e')
          }
        }
      })
    })
  </script>
</body>
</html>
